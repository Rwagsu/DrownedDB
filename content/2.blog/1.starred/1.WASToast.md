---
title: 搞定 Windows App SDK 的 Toast 通知
description: 感谢大佬指点 awa
icon: streamline:toast

badges:
  - value: 2024-03-11
    icon: ri:window-2-line
    target: _blank

authors:
  - name: Rwagsu
    username: Rwagsu
    avatar: https://www.github.com/Rwagsu.png
    to: https://github.com/Rwagsu
    target: _blank
---

::alert{type="info" icon="lucide:info"}
Σ(っ °Д °;)っ 别被水印误会! 这篇文章是我在 CSDN 里发的, 但是由于我不想在 CSDN 里了, 所以我把文章搬到了这里, 但是原图片已经被我删了, 只好拿 CSDN 的水印版用了 QAQ (当然相较于 CSDN 原文还是做了些改进的)
::

::alert{type="warning" icon="lucide:triangle-alert"}
由于 Rwagsu 将自己的主力框架从 Windows App SDK 迁移到了 Uno Platform(这玩意有够难用的), 所以这篇文章很可能随着 NuGet 包的更新而失效(虽然这玩意**两年半**都没更新), 但如果你发现新版本无法使用, 你可以在文章底部发评论或者直接发个 issues(最希望你提交个 pr 啦 awa), 等我有时间的时候我会处理这个问题的 ;)
::

为了搞定这个问题, 我搞了整整一个月, 最后还是一个大佬帮我搞的🥴

~~记得加 CommunityToolkit.WinUI.Notifications NuGet 包~~
现在 CommunityToolkit.WinUI.Notifications 已经集成到了 Windows App SDK.

::steps{:level="2"}
## 修改 `Package.appxmanifest`文件 (未打包项目跳到第二步)

```xml [Package.appxmanifest]
<Extensions>
    <!--Specify which CLSID to activate when app notification clicked-->
	<desktop:Extension Category="windows.toastNotificationActivation"> <!-- [!code ++] -->
		<desktop:ToastNotificationActivation ToastActivatorCLSID="REPLACED-WITH-YOUR-GUID-114514191981" /> <!-- [!code ++] -->
	</desktop:Extension> <!-- [!code ++] -->

    <!--Register COM CLSID LocalServer32 registry key-->
	<com:Extension Category="windows.comServer"> <!-- [!code ++] -->
		<com:ComServer> <!-- [!code ++] -->
			<com:ExeServer Executable="TestApp1.exe" Arguments="-ToastActivated" DisplayName="Toast activator"> <!-- [!code ++] -->
				<com:Class Id="REPLACED-WITH-YOUR-GUID-114514191981" DisplayName="Toast activator"/> <!-- [!code ++] -->
			</com:ExeServer> <!-- [!code ++] -->
		</com:ComServer> <!-- [!code ++] -->
	</com:Extension> <!-- [!code ++] -->
</Extensions>
```

记得将里面的 `TestApp1.exe` 换成自己的应用名称 (记得加 `.exe` 后缀), 以及将里面的 `REPLACED-WITH-YOUR-GUID-114514191981` (好臭啊(恼)) 替换成自己的 GUID (可以用 Visual Studio 自带的 GUID 生成器)

## 设置 Toast 通知:

```csharp
var toast = new ToastContentBuilder();
toast.AddArgument("action", "viewConversation");
toast.AddArgument("conversationId", 9813);
toast.AddText("Andrew sent you a picture");
toast.AddText("Check this out, The Enchantments in Washington!");
toast.Show();
```

::field-group
  ::field{name="AddArgument(key, value)" type="string, string"}
  向 Toast 额外添加一些数据, 在用户点击 Toast 通知时这些数据会传递给应用程序.

  - `AddArgument("action", "viewConversation")`{lang="csharp"} 告诉应用, 当通知被点击时, 意图是 `viewConversation`.
  - `AddArgument("conversationId", 9813)`{lang="csharp"} 同时告诉应用, 具体要查看的是哪个对话 (ID 为 9813 的对话).

  如果只是简单的 "点击通知时打开主页面", 则不需要 AddArgument 参数.
  但如果 Toast 能够与应用程序交互, 那么就需要通过 AddArgument 来传递相关信息.
  ::
  ::field{name="AddText(text)" type="string"}
  向 Toast 添加文本, 第一段文本将被转换为标题.
  ::
  ::field{name="Show()"}
  弹出 Toast 通知.
  ::
  ::field{name="AddButton(button)" type="ToastButton"}
  向 Toast 添加按钮, 最多只能有 5 个按钮.
  ToastButton 类型在稍后介绍.
  ::
::

真把属性写完有点太多了(￣▽￣)"

:read-more{title="AppNotificationBuilder Class" to="https://learn.microsoft.com/zh-cn/windows/windows-app-sdk/api/winrt/microsoft.windows.appnotifications.builder.appnotificationbuilder?view=windows-app-sdk-1.7"}

至此, 一个简单的 Toast 通知就设置完毕了.

## 加入按钮

在 `toast.Show()`{lang="csharp"} 之前, 插入:

```csharp
toast.AddButton(new ToastButton()
    .SetContent("Like")
    .AddArgument("action", "token1")
    .SetBackgroundActivation());
```

::field-group
  ::field{name="SetContent(text)" type="string"}
  向按钮添加文本.
  ::
  ::field{name="AddArgument(key, value)" type="string, string"}
  向 Toast 额外添加一些数据, 在用户点击 Toast 按钮时这些数据会传递给应用程序.

  - `AddArgument("action", "token1")`{lang="csharp"} 告诉应用, 当按钮被点击时, 意图是 `token1`.
  ::
  ::field{name="SetBackgroundActivation()"}
  设置在用户点击按钮时不换出主界面.

  可以和 `SetForegroundActivation()`{lang="csharp"} 共存, 但不推荐, 最终会使用最后设置的那一个.
  ::
  ::field{name="SetForegroundActivation()"}
  设置在用户点击按钮时唤出主界面.

  可以和 `SetBackgroundActivation()`{lang="csharp"} 共存, 但不推荐, 最终会使用最后设置的那一个.
  ::
::

然后在程序入口处 (通常是 App.xaml.cs) 加入:

```csharp [App.xaml.cs]

public App() {
    ToastNotificationManagerCompat.OnActivated += ToastNotificationManagerCompat_OnActivated; // [!code ++]
}

private static void ToastNotificationManagerCompat_OnActivated(ToastNotificationActivatedEventArgsCompat args) { // [!code ++]
    var ToastClickArgs = CommunityToolkit.WinUI.Notifications.ToastArguments.Parse(args.Argument); // [!code ++]
    if (ToastClickArgs.Count > 0) { // [!code ++]
        foreach (var ToastClickItem in ToastClickArgs) { // [!code ++]
            switch (ToastClickItem.Value) { // [!code ++]
                case "token1": // [!code ++]
                    // 执行代码块 [!code ++]
                    Debug.WriteLine("成了!!!!!!!!!!"); // [!code ++]
                break; // [!code ++]
            } // [!code ++]
        } // [!code ++]
    } // [!code ++]
} // [!code ++]

```

Toast 通知 或按钮被点击时会触发 OnActivated 事件, 所以通过寻找 `args` 的参数即可正确执行代码.

这里的 `token1` 代表着刚刚在 Button 里创建的 `token1`, 可以随意修改, 只要两个名称一样就行.

如果你想创建多个按钮, 那么就多添加几个 case.
::

好, 如果你的代码是现抄的, 那么你在执行第二步的代码时, 会发现有通知出来了 **(记得把勿扰模式关掉)**.

如果你点击了 "Like" 按钮, 你会发现输出中出现了:

``` [Console]
成了!!!!!!!!!!
```

注意, 第一步是已打包项目中必须执行的, 否则你见到的将是程序抛出一大串又臭又长的异常(

(大佬就是厉害)
